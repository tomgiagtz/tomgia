[
  
  {
    "title": "Reynolds' Boids with C# and Unity",
    "url": "/posts/reynolds'-boids-with-c-and-unity/",
    "categories": "Code Samples",
    "tags": "Unity, C#, AI",
    "date": "2023-08-01 00:00:00 -0400",
    





    
    "snippet": "GitHubIn 1986, Craig Reynolds created a model to describe the motion of flocks. These flocks recreated the motion of animals that move in groups, such as fish or birds, and he called these simulate...",
    "content": "GitHubIn 1986, Craig Reynolds created a model to describe the motion of flocks. These flocks recreated the motion of animals that move in groups, such as fish or birds, and he called these simulated animals boids. With three simple rules, this model creates very naturalistic motion. What follows is a summary of my implementation of this model, using C# and Unity.Three Simple RulesOur base representation of our boids without any behavior will be them just moving in some initial direction with some initial speed. The boid would move along this velocity vector infinitely, never changing direction. With Reynolds’ three simple rules, we can add behavior to this motion, and life to the boids. The three rules are as follows      Separation    Steering away from neighboring boids that are too close.        Alignment    Steering towards the average of the velocities of all neighboring boids.        Cohesion    Steering towards the center of mass of all neighboring boids.  With these rules, we can start with the implementation.Unity Setup and the First Problem to SolveI started by jumping in Unity, getting my scene setup, and creating a BoidController class that sets its initial velocity to some random unit vector. I’m going to assume this is a baseline thing for anyone reading this, if you need help getting this far, there are plenty of Unity tutorials on YouTube. Otherwise, if you’ve set up a character controller before, this will follow in the same vein.Also created a FlockController class, which is responsible for creating the boids when you hit play. I used a List of GameObjects to store references to these boids, which we’ll need so we can find a list of our neighbors.void Start() {        for (int i = 0; i &lt; settings.numBoids; i++) {            BoidController boid = Instantiate(settings.boidPrefab).GetComponent&lt;BoidController&gt;();            boid.Initialize(settings);            boids.Add(boid);        }}You’ll note I’m using some settings objects to get all of these parameters. This is a ScriptableObject I created called BoidsSettings, which is designed to represent all of our parameters for the boids and flock.Our first problem here is that the boids just move along their initial velocity vector, so the first problem was to contain the boids in some volume, or create some bounds for our simulation. For this, we need a minimum range for the boids, which will let us know how close the boids are allowed to get to the edge, and a max range, which will create a sphere centered on the origin, which represents our bounds for the simulation. Here’s my commented code for this:Vector3 EdgeAvoidance() {        //if the boid is inside the spawn radius, but within it's avoidance distance        if (transform.position.magnitude &gt; settings.maxRadius - settings.avoidanceRadius) {            //get the distance from the boid to the edge of the spawn radius            float distance = settings.maxRadius - transform.position.magnitude;            //set the strength to the inverse square of the distance            float strength = 1 / (distance * distance);            //invert the direction            Vector3 avoidanceDir = -transform.position.normalized;            //return multiplied with our strength            return avoidanceDir * settings.avoidanceWeight * strength;        }        return Vector3.zero;    }How do boids “see” their neighbors?This is our first truly complex problem to solve, but it’s also probably the toughest step in this implementation. Don’t worry, it only gets easier afterward! The first thing to set up here is a new setting for the sight radius of our boids, I called it perceptionRadius . Each boid should be aware of all the other boids within this radius, these are their neighbors.Brute Force1200 boids, each checking every other boidWe need to find every boid within that perception radius, and the brute force method would be to loop through all the boids, checking each distance and storing the boids with a distance less than perceptionRadius.  The problem with this is every boid is checking every other boid on every frame. This is a computing nightmare, so we must find a better solution. There are better options than what I did, such as using an octree or spatial hash. With the implementations, the boids don’t have to search the entire simulation, as they generally map locations to groups, which is far more efficientIf I had known that Unity’s Physics library makes use of these methods under the hood, then I would have used them instead. I mistakenly assumed that it would require a RigidBody on each boid, which would not scale well. If I continue to work on this project, I would go back and use those instead. The implementation would change, but the efficiency boost would be notable, allowing for 5000+ boids, instead of my solution, which starts to chug at around 2500 boids.Brute Force LightBecause I was over-assuming the inefficiencies of the built-in physics library, I tried to find some middle ground. The first thing I did was limit how many neighbors each boid could have with a parameter, maxNeighbors. Instead of trying to find every boid within the perception radius, we only try to find boids until we hit that max, and then stop looking.public BoidController[] BruteForceLight(BoidController boid) {        //create a new array of neighbors        BoidController[] nearbyBoids = new BoidController[settings.maxNeighbors];        int count = 0;        //get a random int between 0 and the number of boids as our offset        int offset = Random.Range(0, boids.Count);        //loop through all the boids        for (int i = 0; i &lt; boids.Count; i++) {                        //if inside the radius, add to the list and increment count            if (Vector3.Distance(boid.transform.position, other.transform.position) &lt; settings.maxRadius) {                nearbyBoids[count] = other;                count++;            }            //if num neightbors == maxNieghbors, stop searching            if (count &gt;= settings.maxNeighbors) break;        }        //return list of boids        return nearbyBoids;    }Now that we can find our neighbors, we have everything we need to start on the three rules, I started with Separation.SeparationAll we need to do here is loop through our neighbors, check if the distance to that neighbor is less than our avoidanceRadius (the same value we used for EdgeAvoidance). If the neighbor is inside that radius, we use the inverse square law to determine our strength and move in the opposite direction of that neighbor. This result is added up and averaged for all our neighbors.All we need to do here is loop through our neighbors, check if the distance to that neighbor is less than our avoidanceRadius (the same value we used for EdgeAvoidance). If the neighbor is inside that radius, we use the inverse square law to determine our strength and move in the opposite direction of that neighbor. This result is added up and averaged for all our neighbors.Vector3 Separation() {        //our result vector, initialized to 0,0,0        Vector3 separationDir = Vector3.zero;        //for each neighbor        foreach (BoidController neighbor in neighbors) {            if (neighbor != null) {                //vector between the neighbor and this boid                Vector3 toNeighbor = transform.position - neighbor.transform.position;                //magnitude is the distance between the two                float distance = toNeighbor.magnitude;                if (distance &lt; settings.avoidanceRadius) {                    //use inverse square law to determine strength                    separationDir += toNeighbor.normalized * 1 / distance * distance;                }            }        }        //still gets scaled linearally by the weight        return separationDir.normalized * settings.separationWeight;    }This looks quite similar to our EdgeAvoidance function, and that’s because it is! The only difference is we’re checking against our distance to boids, instead of the distance to our bounds.An Issue Crops UpAfter implementing this, I noticed this was creating some clumping among the boids. The boids weren’t really separating. I realized this was an issue with how we find neighbors. Since the list of all boids is static, each boid is finding the same neighbors over and over. To solve this, I added a (controllable) random offset to our BruteForceLight function.public BoidController[] BruteForceLight(BoidController boid) {        ...        int offset = Random.Range(0, boids.Count);        //loop through all the boids        for (int i = 0; i &lt; boids.Count; i++) {            //randomly offset search based on randomNeighbor setting            int index =  settings.randomNeighbors ? (i + offset) % boids.Count : i;            if (settings.randomNeighbors) {                index = (i + offset) % boids.Count;            }            //get the boid out of the list            BoidController other = boids[index];\t\t\t\t\t\t...As you can see in this video, this resolves the clumping issue.Alignment + CohesionSimilar to cohesion, we have to start by looping through the list of neighbors. We add up all of the neighbor’s velocity vectors and then take the average. This average is our Alignment vector.Vector3 Alignment() {        Vector3 alignmentDir = Vector3.zero;        //keeping track of how many neighbors regardless of max neighbors        int neighborCount = 0;        // add all velocties of valid neighbors        foreach (BoidController neighbor in neighbors) {            if (neighbor != null) {                alignmentDir += neighbor.velocity;                neighborCount++;            }        }        //take average of all neighbors velocity        alignmentDir /= neighborCount;        //scale by weight        return alignmentDir.normalized * settings.alignmentWeight;    }As we can see, we have all the parameters set up from Separation. I added in alignmentWeight so we can tweak the strength of this force in the editor.Cohesion followed right after. This time we get the center of mass of our neighbors by adding all of their positions (not velocity) and averaging the result.Vector3 Cohesion() {        Vector3 centerOfMass = Vector3.zero;        int neighborCount = 0;        foreach (BoidController neighbor in neighbors) {            if (neighbor != null) {                centerOfMass += neighbor.transform.position;                neighborCount++;            }        }        if (neighborCount &gt; 0) {            centerOfMass /= neighborCount;            return (centerOfMass - transform.position).normalized * settings.cohesionWeight;        }        return Vector3.zero;    }This also gets a cohesionWeight , controllable from the editor. After playing with each of the parameters, I was able to dial in this simulation of 2000 boids:ConclusionFor the future I’d love to make this something that is easily sharable, so anyone can go in and experience what control over a flock feels like. As I mentioned, I would also go back to improve the efficiency of finding neighbors. If given enough time, I would change over to using a Compute Shader wherever possible. Running this on the GPU would allow this simulation to reach a massive scale, with hundreds of thousands of boids flocking in real time.There are also additional rules we can add to extend the Flocks behavior, including Predators, Leaders, and smaller flocks within the whole. You can learn more about them in the later sources below.It’s really interesting to think about how such simple rules create an organic motion. I’m really happy with how this came out. I like to think of it as a parameter driven toy. I created all these parameters that I can change during runtime and watch as they take effect in the simulation. It’s really fun to see how each parameter affects the simulation, turning some off to see what happens. The nice thing about this is that it’s art directable,  a school of fish would behave quite differently than a flock of birds, but we have the ability to tweak everything to match that expected behavior.SourcesReynolds’ Website on Boidshttps://www.red3d.com/cwr/boids/The Coding Train - Coding Challenge #124: Flocking Simulationhttps://www.youtube.com/watch?v=mhjuuHl6qHMSebastian Lague - Coding Adventure: Boidshttps://www.youtube.com/watch?v=bqtqltqcQhwNeat AI - Neat AI Does Predator Boidshttps://www.youtube.com/watch?v=rkQB4zEJggEHarmen de Weerd- Boids: Flocking made simplehttps://www.harmendeweerd.nl/boids/"
  },
  
  {
    "title": "Bean Bandits — Player Generated Board Game",
    "url": "/posts/bean-bandits-player-generated-board-game/",
    "categories": "Code Samples",
    "tags": "Unity, C#, Gameplay",
    "date": "2023-07-19 00:00:00 -0400",
    





    
    "snippet": "Betrayal at the House on the Hill inspired me to recreate a player generated dungeon for the party game, Bean Bandits and the Curse of Skol. In a Mario Party style ‘overworld’, players race through...",
    "content": "Betrayal at the House on the Hill inspired me to recreate a player generated dungeon for the party game, Bean Bandits and the Curse of Skol. In a Mario Party style ‘overworld’, players race through the dungeon to collect 3 gems, then escape through the starting area. After each round, players face off in a minigame.Basics of my SystemThis kind of level generation is mostly random and completely controlled by the players. On each turn, players can uncover new rooms.  They pick from a prepared deck of cards of various types, including each of the possible passages, gems or traps.  As players explore, they “pick” a card and control the rotation of the room, whenever it is not forced. When they move to an already discovered tile, they simply move there.public void HandlePlayerSelectTile(PlayerNum playerIndex) {        //...        PawnPlayerController currPlayer = players[(int) playerIndex];        Tile currTile = BoardManager.Instance.currTile;        currPlayerDir = BoardManager.GetDirectionBetweenTiles(BoardManager.Instance.GetTile(currPlayer.boardPosition), currTile);                switch (currTile.state) {            case TileState.Hidden:                currTile.SetState(TileState.Revealing);                break;            case TileState.Rotating:                if (currTile.isValidRotation) {                    HandlePlayerPlacedTile(playerIndex);                }                break;            case TileState.Revealed:                //Move to tile                MovePlayer(currPlayer, currTile);                break;        }    }This deck allowed us to test different ratios of these cards, to control the length of the game, in terms of rounds. We also wanted to accelerate and ensure the discovery of special tiles. So, each discovery without a special tile, increased the pull rate slightly. Winning minigames also provides a boost to finding gems. Using Machinations, were able to balance these bonuses resulting in a game that would take about 10 rounds to find every gem.private TileData DealTileControlled(PawnPlayerController player) {        float rand = Random.Range(0f, 1f);        // check if rolled a special tile        bool isSpecial = rand &lt; baseSpecialChance + (specialChanceDelta * player.numMovesSinceSpecialTile);        // if rolled a special tile, and its not the first round        if (deck.Count == 0 ||(isSpecial &amp;&amp; BoardGameManager.Instance.roundNumber &gt;= 1)) {            return RemoveTileFromDeck(specialDeck);        } else {            return RemoveTileFromDeck(deck);        };    }TilesTileData | Scriptable ObjectTiles are not MonoBehaviors, they act as a Model in the MVC design pattern. A ScriptableObject defines each type of tile, and holds a reference to a set of Prefabs, which are selected at random when a tile is chosen:[CreateAssetMenu(fileName = \"Tile\", menuName = \"Board Game Objects/Tile\", order = 1)]public class TileData : ScriptableObject {    public TileType tileType;    public Mesh mesh;    public GameObject[] prefabs;    public bool endsTurnOnReveal;    public bool hasGem = false;    [Tooltip(\"[North, East, South, West]\")]    public bool[] connections = new bool[] {true, true, true, true};    public int GetNumConnections() {        int res = 0;        for (int i = 0; i &lt; connections.Length; i++) {            if (connections[i]) {                res++;            }        }        return res;    }    public GameObject GetPrefab() {        if (prefabs != null &amp;&amp; prefabs.Length &gt; 0) {            return prefabs[Random.Range(0, prefabs.Length)];        }        return null;    }}public enum TileType {        Corner,        Cross,        Tcross,        Hall,        Start,        Treasure,        Trap,        Hidden}Using this data, each tile controls its effect when a player enters it based off what the tile type ispublic void OnPlayerEnterTile(PawnPlayerController _player) {    switch (tileType) {        case TileType.Start:            if (debug.showDebug &amp;&amp; debug.logState) Debug.Log(\"Player entered start tile\");            Vector2Int playerHomePos = BoardManager.Instance.GetStartPosition((int) _player.playerIndex);            if (playerHomePos == position) {                _player.StashRelics();            }        break;        case TileType.Trap:            if (debug.showDebug &amp;&amp; debug.logState) Debug.Log(\"Player entered trap tile\");            _player.numMovesSinceSpecialTile = 0;            animator.HandleTrapTile(_player, () =&gt; _player.HandleTrap());            break;        case TileType.Treasure:            if (debug.showDebug &amp;&amp; debug.logState) Debug.Log(\"Player entered treasure tile\");            if (!animator.hasGem) return;            if (_player.AddRelic()) {                animator.MoveGemToPlayer(_player);            } else {                if (debug.showDebug &amp;&amp; debug.logState) Debug.Log(\"Player has no room for relic\");                animator.MoveGemToPlayer(_player, canPlayerHold: false);            }            _player.numMovesSinceSpecialTile = 0;            // animator.SetState(TileState.Error);            break;        default:            _player.numMovesSinceSpecialTile++;            break;    }}TileAnimator | Code Driven AnimationsFinally, the TileAnimator class is a MonoBehavior and acts as a View class from MVC. Given a tile, it represents the visuals of a tile, and instances and animates the prefab. All animations are done using a Tweening library from Surge.// create visuals from tile datapublic void SetType(TileData tileData) {    data = tileData;    hasGem = data.hasGem;    Mesh newMesh = Instantiate(data.mesh);    meshFilter.sharedMesh = newMesh;    if (data.tileType == TileType.Hidden &amp;&amp; state != TileState.Highlighted) {        HideMesh();    }    if (data.GetPrefab() != null &amp;&amp; decoPrefab == null) {        decoPrefab = Instantiate(data.GetPrefab(), transform);    }}// animate rotation of tile public void SetRotation(Direction dir, bool animate = true) {    rotation = dir;    if (animate) {        Tween.Rotation(transform, Tile.DirectionToEulerAngles(dir), 0.5f, 0, Tween.EaseInOut);    } else {        transform.rotation = Quaternion.Euler(Tile.DirectionToEulerAngles(dir));    }}Watch out for traps!In reflection, this was a massive undertaking. I alone wrote over 2000 lines of code in about 7 weeks, while completing other classes. Though it is by no means perfect, it was good practice in learning to effectively split and structure a large codebase."
  }
  
]

